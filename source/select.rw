% -*- mode: noweb; noweb-default-code-mode: R-mode -*-
% Copyright (C) 2011  Gray Calhoun

% This program is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.

% This program is distributed in the hope that it will be useful, but
% WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
% General Public License for more details.

% You should have received a copy of the GNU General Public License
% along with this program.  If not, see
% <http://www.gnu.org/licenses/>.

\name{select}
\alias{select}
\alias{select-methods}
\alias{select,ANY,missing-method}
\alias{select,data.frame,character-method}
\alias{select,dbframe,character-method}
\alias{select,dbframe,list-method}
\alias{select,default,missing-method}
\alias{select,list,character-method}
\alias{generate.select.sql}
\title{Retrieve records from a dbframe}
\newcommand{\sql}{\acronym{sql}}
\newcommand{\sqlite}{\acronym{sql}ite}

\description{[[select]] is a wrapper for the \sql select query and is
  used to retrieve records from a [[dbframe]] object.
  [[generate.select.sql]] assembles a valid \sql select statement from
  its arguments.  The arguments map to clauses in the \sql select
  statement, so you may need to consult an introduction to \sql to best
  use these functions.}

\usage{
select(x, cols, as.data.frame = TRUE,...)

generate.select.sql(table, cols = "*", where = NULL, group.by = NULL, 
                    having = NULL, order.by = NULL, limit = NULL,...)
}

\arguments{
  \item{x}{A [[dbframe]] object that references the table of interest.}
  \item{table}{A character object containing the name of the \sql table to query.}
  \item{cols}{A character vector containing the column names (or
    functions of the column names) to retrieve from the database.}
  \item{where}{A character object that contains conditions to use to
    filter the records.}
  \item{group.by}{A character vector that defines groups of records to
    combine with an aggregate function.}
  \item{having}{A character object that filters the groups defined by \dQuote{group.by}.}
  \item{order.by}{A character vector that lists the columns to be used
    for sorting the results.}
  \item{limit}{A character vector or number that limits and offsets the
    \sql query results.}
  \item{\dots}{Additional arguments to pass to [[dbGetQuery]].}
  \item{as.data.frame}{Logical; if [[TRUE]], execute the query and
  return the results as a data frame.  If [[FALSE]], return a dbframe
  that has the \sql statement for the query as its \dQuote{table}}
}

\references{
\sql as understood by \sqlite. \url{http://www.sqlite.org/lang_select.html}
}
\section{Implementation}{
The inidividual methods do some minor parsing, but most of the work is
done by [[generate.select.sql]].
  
<<*>>=
    generate.select.sql <- function(table, cols = "*", where = NULL, 
      group.by = NULL, having = NULL, order.by = NULL, limit = NULL, ...) {

      <<Format the "select" part of the statement>>
      <<Format the "group by" part of the statement>>
      <<Format the "order by" part of the statement>>
      <<Format the "having" part of the statement>>
      <<Format the "where" part of the statement>>
      <<Format the "limit" part of the statement>>
      return(paste("select", cols, "from", table, where, 
                   group.by, having, order.by, limit))
    }

    setGeneric("select", function(x, cols, as.data.frame = TRUE,...)
               standardGeneric("select"))

    setMethod("select", signature = c("ANY", "missing"), 
              function(x, cols, as.data.frame = TRUE,...) {
                <<Execute select for c("ANY", "missing")>>})

    setMethod("select", signature = c("dbframe", "character"), 
              function(x, cols, as.data.frame = TRUE,...) {
                <<Execute select for c("dbframe", "character")>>})

    setMethod("select", signature = c("data.frame", "character"),
              function(x, cols, as.data.frame = TRUE,...) {
                <<Handle arguments and set up the local environment>>
		<<Export the new data frame to a temporary SQLite database>>
                <<Query the new database and close database connection>>
                return(queryresults)
              })

    setMethod("select", signature = c("list", "character"), 
              function(x, cols,...) {
                <<Detect inappropriate uses of the "list" method>>
                <<Define and attach to "main" db>>
                <<Extract the arguments that describe the join>>
                <<Execute the query and return its results>>
              })

    ## setMethod("select", signature = c("dbframe", "list"), 
    ##           function(x, cols,...) {
    ##             <<Handle lists of a single query element>>
    ##             <<Manage arguments for compound queries>>
    ##             <<Construct individual SQL select statements for compound queries>>
    ##             <<Execute query and return data>>
    ##           })
      
      
    <<Define additional useful functions>>
@ Unfortunately, this method doesn't yet allow for joins or compound
queries involving data.frames.  Maybe a better approach would be to
always let the \dQuote{main} database be a temporary one on disk.

\subsection{Assembling the \sql select statement}{
To write the "select" part, we add the [[group.by]] variables and the
[[cols]] variables together (and store them in [[cols]]).
<<Format the "select" part of the statement>>=
    <<Add new group.by variables in front of cols variables>>
    labels <- names(cols)
    labels[nchar(labels) > 0] <- paste("AS", labels[nchar(labels) > 0])
    cols <- paste(cols, labels, collapse = ", ")
@ 
To save typing, I assume that we want to retrieve the grouping variables
and so we don't have to specify them explicitly in the [[cols]] vector.
I think it makes sense to have the grouping variables on the left side
of the results set instead of the right side.  The next code chunk does
both of those.
<<Add new group.by variables in front of cols variables>>=
    cols <-
      if (is.null(cols)) {
        group.by
      } else if (is.null(group.by)) {
        cols
      } else {
        if (is.null(names(cols)))
          names(cols) <- rep("", length(cols))
        if (is.null(names(group.by))) 
          names(group.by) <- rep("", length(group.by))
        c(group.by[!(names(group.by) %in% names(cols))
                    |  nchar(names(group.by)) == 0], cols)
      }
@ 

Managing the other arguments is easy.  If they're [[NULL]] we replace
the variable with an empty string; if they're not, we add the
appropriate label and replace the variable with a character object that
contains a clause for the \sql statement.
<<Format the "group by" part of the statement>>=
    group.by <- 
      if (is.null(group.by)) {
        "" 
      } else {
        paste("group by", paste(group.by, collapse = ", "))
      }
@ 

<<Format the "order by" part of the statement>>=
    order.by <- 
      if (is.null(order.by)) {
        ""
      } else {
        paste("order by", paste(order.by, collapse = ", "))
      }
@ 

<<Format the "having" part of the statement>>=
    having <-
      if (is.null(having)) {
        ""
      } else {
        paste("having", having)
      }
@ 

<<Format the "where" part of the statement>>=
    where <-
      if (is.null(where)) {
        "" 
      } else {
        paste("where", where)
      }
@ 

<<Format the "limit" part of the statement>>=
    limit <- 
      if (is.null(limit)) {
        "" 
      } else {
        paste("limit", limit)
      }
@ 
}
\subsection{Details of argument handling for simple queries}{
  The individual methods just call [[generate.select.sql]] and execute
  the select statement.    
If [[cols]] is "missing" it returns results for
[[cols]] equal to "*" (i.e. all of the columns of the table).
<<Execute select for c("ANY", "missing")>>=
    select(x, "*", as.data.frame,...)
@ 

<<Execute select for c("dbframe", "character")>>=
    if (!is.linked(x)) {
      warning("Table does not exist in the data base")
      return(list())
    }
    arguments <- list(table = tablename(x), cols = cols,...)
    sql.statement <- do.call("generate.select.sql", arguments)
    if (as.data.frame) {
      dbc <- dbConnect(x)
      d <- do.call("dbGetQuery", c(conn = dbc, statement = sql.statement,
                                   arguments))
      dbDisconnect(dbc)
    } else {
      if (is.null(arguments$readonly)) {
        readonly <- readonly(x)
      } else {
        readonly <- arguments$readonly
        arguments$readonly <- NULL
      }
      d <- do.call("new", c(Class = "dbframe", table = sql.statement,
                   readonly = readonly, dbConnect.arguments = arguments))
    }
    return(d)
@

<<Handle arguments and set up the local environment>>=
    if (!as.data.frame)
      warning("'as.data.frame' ignored when selecte is called on a data.frame.")
    tablename <- "dataframe"
    require(RSQLite)
    require(RSQLite.extfuns)
@ 

<<Export the new data frame to a temporary SQLite database>>=
    dbc <- dbConnect("SQLite", dbname = ":memory:")
    dbWriteTable(dbc, tablename, x, row.names = FALSE)
@ 

<<Query the new database and close database connection>>=
    sql.statement <- generate.select.sql(tablename, cols,...)
    queryresults <- dbGetQuery(dbc, sql.statement)
    dbDisconnect(dbc)
@
}
\subsection{Details of argument handling for joins}{
  So far, I'm only supporting joins for dbframes that are linked to
  \sqlite data bases and for data.frames. 
<<Detect inappropriate uses of the "list" method>>=
    if (length(x) == 1) return(select(x[[1]], cols,...))
    if (is.null(names(x))) names(x) <- LETTERS[seq_along(x)]
    tableclasses <- sapply(x, class)
    if (!all(tableclasses %in% c("dbframe_sqlite", "data.frame")))
      stop("Some of your dbframes aren't supported yet")
@ 

One nice feature of this function is that it handles all of the
\dQuote{attach} commands that are necessary to merge tables that exist
in different databases.  If all of the dbframes link to the same
database, then that one will obviously be the main database; otherwise
we connect to a temporary \sqlite database and attach everything there.
<<Define and attach to "main" db>>=
    dbnames <- tablenames <- rep(NA, length(x))
    for (s in seq_along(x)) {
      if (tableclasses[s] == "dbframe_sqlite") {
        dbnames[s] <- dbname(x[[s]])
        tablenames[s] <- tablename(x[[s]])
      } else {
        dbnames[s] <- "main"
        tablenames[s] <- names(x)[[s]]
      }
    }
    if (isTRUE(sum(!duplicated(dbnames)) == 1)) {
      maindbc <- dbConnect(x[[1]])
      dbnames <- rep("main", length(x))
      dbalias <- dbnames
    } else {
      maindbc <- dbConnect("SQLite", dbname = ":memory:")
      <<Write dataframes to the main db>>
      <<Attach sqlite_dbframes to the main db>> 
    }
@ 
Any data frames are just going to be written to the temporary database.
<<Write dataframes to the main db>>=
    for (s in which(tableclasses == "data.frame")) {
      dbWriteTable(maindbc, names(x)[[s]], x[[s]], row.names = FALSE)
    }
@ 
Tables that already exist in other databases are attached to the
temporary database.
<<Attach sqlite_dbframes to the main db>>=
    dbalias <- dbnames
    dbcount <- 0
    unique.databases <- unique(dbnames[dbnames != "main"])
    for (db in unique.databases) {
      dbcount <- dbcount + 1
      currentalias <- sprintf("ALIAS%d", dbcount)
      dbalias[dbalias == db] <- currentalias
      r <- dbSendQuery(maindbc, sprintf("attach database '%s' as %s", db, currentalias))
      dbClearResult(r)
    } 
@ 
The columns are already specified for the query; the only thing to do is
assemble the \sql code for the "table" part.
If the join type is not specified, the default is to do an inner join;
there is no default for \dQuote{on} or \dQuote{using}, so one (and only
one) of those arguments must be specified.
<<Extract the arguments that describe the join>>=
    arguments <- list(...)
    join  <- extract.element("join", "inner", length(x) - 1, arguments)
    on    <- extract.element("on", NA, length(x) - 1, arguments)
    using <- extract.element("using", NA, length(x) - 1, arguments)
    if (!all(xor(is.na(on), is.na(using))))
      stop("'on' and 'using' can't both be specified for the same join.")
    arguments$join  <- NULL
    arguments$on    <- NULL
    arguments$using <- NULL
    arguments$cols  <- cols
    arguments$table <- paste(collapse = " ", c(
      sprintf("%s.%s %s", dbalias[1], tablenames[1], names(x)[1]),
      sprintf("%s join %s.%s %s %s", join, dbalias[-1], tablenames[-1], names(x)[-1], 
                ifelse(is.na(on), sprintf("using(%s)", using), sprintf("on %s", on)))))
@ 
Actually executing the query is the same as for the other methods.
We're not going to worry about detaching the tables explicitly, since we
know that they were only attached if we're using a temporary data base.
<<Execute the query and return its results>>=
    return(dbGetQuery(maindbc, do.call(generate.select.sql, arguments)))
@ 
}
\subsection{Miscellaneous function}{
<<Define additional useful functions>>=
    <<Define tableSQL>>
    <<Define extract.element>>
@   

<<Define tableSQL>>=
    tableSQL <- function(tablenames, join, on, using) {
    paste(tablenames[1], names(tablenames)[1],
          paste(join, tablenames[-1], names(tablenames)[-1], 
                c(ifelse(is.na(on), paste("using(", using, ")", sep = ""),
                         paste("on", on)))))
	  	       }
@ 

<<Define extract.element>>=
    extract.element <- function(name, default, length.required, argument.list) {
      v <- if (name %in% names(argument.list)) argument.list[[name]] else default
      if (is.na(length.required) | length(v) == length.required) return(v)
      else if (length(v) == 1) return(rep(v, length.required))
      else stop("Incorrect length of argument")
    }
@ 
}}

\section{Unit Tests}{
I just have some basic sanity-check type unit tests; i.e. do the
functions run at a minimal level.
<<test-select.R>>=
    library(testthat)
    data(chickwts)
    chickwts$feed <- as.character(chickwts$feed)
    test_that("insert and select work", {
      <<Individual tests that insert and select work>>})
    test_that("column renaming scheme works", {
      <<Individual tests that column renaming works>>})
    test_that("joins work", {
      <<Individual tests that joins work>>})
@ 

First we'll check that the methods defined on data frames work, then
that they work for dbframes.
<<Individual tests that insert and select work>>=
    expect_that(chickwts, is_equivalent_to(select(chickwts)))
    <<Create temporary test database and dbframe>>
    insert(testdbframe) <- chickwts
    expect_that(chickwts, is_equivalent_to(select(testdbframe)))
    <<Remove temporary test database>>
@ 

<<Individual tests that column renaming works>>=
    expect_that(
      c("feed", "AverageWeight"), 
      is_identical_to(names(select(chickwts, 
           c(AverageWeight = "avg(weight)"), group.by = "feed"))))
    <<Create temporary test database and dbframe>>
    insert(testdbframe) <- chickwts
    expect_that(
      c("feed", "AverageWeight"), 
      is_identical_to(names(select(testdbframe, 
           c(AverageWeight = "avg(weight)"), group.by = "feed"))))
    <<Remove temporary test database>>
@ 

<<Individual tests that joins work>>=
##    select(list(chickwts, chickwts), using = "feed")
  
@

<<Create temporary test database and dbframe>>=
    testdbfile <- tempfile(fileext = ".db")    
    testdbframe <- dbframe("select1", testdbfile)
    clear(testdbframe)
@ 

<<Remove temporary test database>>=
    unlink(testdbfile)
@ 
}

\examples{
filename <- tempfile(fileext = ".db")
data(chickwts)
chicksdb <- dbframe("select1", dbname = filename, 
                    clear = TRUE, data = chickwts)
select(chicksdb, where = "weight > 200", order.by = "weight")
select(chicksdb, c(averageweight = "avg(weight)"), group.by = "feed")
select(chicksdb, c(averageweight = "avg(weight)"), group.by = "feed",
       having = "averageweight > 250")

## and an example of querying the data frame directly
select(chickwts, c(averageweight = "avg(weight)"), 
       group.by = c(thefeed = "feed"))
avgwts <- dbframe("select2", dbname = filename, clear = TRUE,
                  data = select(chickwts, c(averageweight = "avg(weight)"), 
                                group.by = c(thefeed = "feed")))
## an example of a join
select(list(a = chickwts, b = avgwts), c("feed", "weight", "averageweight"),
       on = ("feed = thefeed"))
}

\keyword{methods}
\keyword{database}
