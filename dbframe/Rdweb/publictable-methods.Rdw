\name{publictable-methods}
\docType{methods}
\alias{publictable-methods}
\alias{publictable,data.frame-method}
\alias{publictable,dbframe-method}
\title{Methods to print nice-looking tables.}
\description{Methods to print nice-looking tables.}

\section{Methods}{
\describe{Add some description here.

\item{\code{signature(object = "data.frame")}}{
%%  ~~describe this method here~~
}

\item{\code{signature(object = "dbframe")}}{
%%  ~~describe this method here~~
}
}}

\seealso{\link{xtable}, \code{\link{dftable}}}

\section{Implementation}{
  In my research, I usually collect simulation results in the table of
some database.  Summarizing the results then amounts to running a
query to aggregate that data, and then plot or tabulate that query's
ersults.  The [[publictable]] function does this and formats the table
to look nice in Latex, using Latex's ``booktabs'' package and the
[[xtable]] library.  The implementation is straightforward.
<<*>>=
setGeneric("publictable", function(object,...)
  standardGeneric("publictable"))

setMethod("publictable", signature = c("data.frame"),
          function(object,...) dftable(object,...))
@
There's one slightly tricky thing about the \code{dbframe} method: I
let the elipsis to pass arguments to both the \code{select} statement
and to the call on the resulting data frame.
<<*>>=
setMethod("publictable", signature = c("dbframe"),
          function(object,...) {
            arguments <- list(...)
            arguments$dframe <- do.call("select", c(x = object, arguments))
            do.call("dftable", arguments)
          })
@
}
\keyword{methods}
\keyword{printing}
