% -*- mode: noweb; noweb-default-code-mode: R-mode -*-
\name{select}
\alias{select}
\alias{select-methods}
\alias{select,dbframe,character-method}
\alias{select,dbframe,list-method}
\alias{select,dbframe,missing-method}
\alias{select,list,character-method}
\alias{generate.select.sql}
\title{Retrieve records from a dbframe}

\description{[[select]] is a wrapper for the SQL select query and is
  used to retrieve records from a [[dbframe]] object.
  [[generate.select.sql]] assembles a valid SQL select statement from
  its arguments.  The arguments map to clauses in the SQL select
  statement, so you may need to consult an introduction to SQL to best
  use these functions.}

\usage{
select(x, cols,...)

generate.select.sql(table, cols = "*", where = NULL, group.by = NULL, 
                    having = NULL, order.by = NULL, limit = NULL, ...)
}

\arguments{
  \item{x}{A [[dbframe]] object that references the table of interest.}
  \item{table}{A character object containing the name of the SQL table to query.}
  \item{cols}{A character vector containing the column names (or
    functions of the column names) to retrieve from the database.}
  \item{where}{A character object that contains conditions to use to
    filter the records.}
  \item{group.by}{A character vector that defines groups of records to
    combine with an aggregate function.}
  \item{having}{A character object that filters the groups defined by \dQuote{group.by}.}
  \item{order.by}{A character vector that lists the columns to be used
    for sorting the results.}
  \item{limit}{A character vector or number that limits and offsets the
    SQL query results.}
  \item{\dots}{Additional arguments to pass to [[dbGetQuery]]}.
}

\references{
SQL as understood by SQLite. \url{http://www.sqlite.org/lang_select.html}
}

\section{Implementation}{
The inidividual methods do some minor parsing, but most of the work is
done by [[generate.select.sql]].
  
<<*>>=
    generate.select.sql <- function(table, cols = "*", where = NULL, 
      group.by = NULL, having = NULL, order.by = NULL, limit = NULL, ...) {

      <<Format the "select" part of the statement>>
      <<Format the "group by" part of the statement>>
      <<Format the "order by" part of the statement>>
      <<Format the "having" part of the statement>>
      <<Format the "where" part of the statement>>
      <<Format the "limit" part of the statement>>
      return(paste("select", cols, "from", table, where, 
                   group.by, having, order.by, limit))
    }

    setGeneric("select", function(x, cols, ...) standardGeneric("select"))
    setMethod("select", signature = c("dbframe", "missing"), 
              function(x, cols,...) {
                <<Execute select for c("dbframe", "missing")>>})
    setMethod("select", signature = c("dbframe", "character"), 
              function(x, cols,...) {
                <<Execute select for c("dbframe", "character")>>})
@

\subsection{Assembling the SQL select statement}{
To write the "select" part, we add the [[group.by]] variables and the
[[cols]] variables together (and store them in [[cols]]).
<<Format the "select" part of the statement>>=
    <<Nullify cols variable if it is undefined>>
    cols <- if (is.null(group.by)) {
      paste(cols, collapse = ", ")
    } else {
      <<Paste new group.by variables in front of cols variables>>
    }
@ 
To save typing, I assume that we want to retrieve the grouping variables
and so we don't have to specify them explicitly in the [[cols]] vector.
I think it makes sense to ahve the grouping variables on the left side
of the results set instead of the right side.  The next code chunk does
both of those.  It's a little awkward because we only want to add
[[group.by]] variables that are not already represented in the [[cols]]
vector; in some cases [[cols]] might contain a renamed or transformed
[[group.by]] variable.  The code tries to be a little smart about those
things, but could probably be improved.
<<Paste new group.by variables in front of cols variables>>=
    paste(collapse = ", ", 
          c(group.by[!sapply(group.by, function(g)
                             g %in% substr(cols, 1, nchar(g)))], cols))
@ 
Setting [[cols]] to [[NULL]] if it doesn't contain a "real" character
string ensures that paste does the right thing.  We might want do set
[[cols]] to "" if we only wanted to return variables specified in
[[group.by]].
<<Nullify cols variable if it is undefined>>=
    if ((length(cols) == 1) && (nchar(cols) == 0)) cols <- NULL
@ 

Managing the other arguments is easy.  If they're [[NULL]] we replace
the variable with an empty string; if they're not, we add the
appropriate label and replace the variable with a character object that
contains a clause for the SQL statement.
<<Format the "group by" part of the statement>>=
    group.by <- 
      if (is.null(group.by)) {
        "" 
      } else {
        paste("group by", paste(group.by, collapse = ", "))
      }
@ 

<<Format the "order by" part of the statement>>=
    order.by <- 
      if (is.null(order.by)) {
        ""
      } else {
        paste("order by", paste(order.by, collapse = ", "))
      }
@ 

<<Format the "having" part of the statement>>=
    having <-
      if (is.null(having)) {
        ""
      } else {
        paste("having", having)
      }
@ 

<<Format the "where" part of the statement>>=
    where <-
      if (is.null(where)) {
        "" 
      } else {
        paste("where", where)
      }
@ 

<<Format the "limit" part of the statement>>=
    limit <- 
      if (is.null(limit)) {
        "" 
      } else {
        paste("limit", limit)
      }
@ 
}
\subsection{Details of argument handling}{
  The individual methods just call [[generate.select.sql]] and execute
  the select statement.  
<<Execute select for c("dbframe", "character")>>=
    dbc <- dbConnect(x)
    d <- dbGetQuery(dbc, generate.select.sql(table(x), cols, ...))
    dbDisconnect(dbc)
    return(d)
@

If [[cols]] is "missing" it returns results for
[[cols]] equal to "*" (i.e. all of the columns of the table).
<<Execute select for c("dbframe", "missing")>>=
    dbc <- dbConnect(x)
    d <- dbGetQuery(dbc, generate.select.sql(table(x),...))
    dbDisconnect(dbc)
    return(d)
@ 
}}

\examples{
filename <- "/tmp/example.db"
data(chickwts)
chicksdb <- dbframe("cluck2", dbname = filename, 
                    clear = TRUE, data = chickwts)
select(chicksdb, where = "weight > 200", order.by = "weight")
select(chicksdb, "avg(weight) as AverageWeight", group.by = "feed",
       having = "AverageWeight > 250")

}

\keyword{methods}
\keyword{database}
