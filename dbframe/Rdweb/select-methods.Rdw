\name{select-methods}
\docType{methods}
\alias{select-methods}
\alias{select,dbframe,character-method}
\alias{select,dbframe,list-method}
\alias{select,dbframe,missing-method}
\alias{select,list,character-method}
\alias{select}
\title{ ~~ Methods for Function \code{select}  ~~}
\description{
 ~~ Methods for function \code{select}  ~~
}
\section{Methods}{
\describe{

\item{\code{signature(x = "dbframe", cols = "character")}}{
%%  ~~describe this method here~~
}

\item{\code{signature(x = "dbframe", cols = "list")}}{
%%  ~~describe this method here~~
}

\item{\code{signature(x = "dbframe", cols = "missing")}}{
%%  ~~describe this method here~~
}

\item{\code{signature(x = "list", cols = "character")}}{
%%  ~~describe this method here~~
}
}}

\section{Implementation}{
<<*>>=
setGeneric("select", function(x, cols, ...) standardGeneric("select"))
@

<<*>>=
setMethod("select", signature = c("dbframe", "missing"), function(x, cols,...) {
  dbc <- dbConnect(x)
  d <- dbGetQuery(dbc, selectSQL(sql(x),...))
  dbDisconnect(dbc)
  d
})
@

<<*>>=
setMethod("select", signature = c("dbframe", "character"), function(x, cols,...) {
  dbc <- dbConnect(x)
  d <- dbGetQuery(dbc, selectSQL(sql(x), cols, ...))
  dbDisconnect(dbc)
  d
})
@

<<*>>=
setMethod("select", signature = c("list", "character"), function(x, cols,...) {
  if (length(x) == 1) return(select(x[[1]], cols,...))
  if (is.null(names(x)))
    stop("If 'x' is a list, it must specify names (aliases) for each element")

  ## extract the arguments that describe the 'join'
  allargs <- list(...)
  join <- paste(extractArg("join", "inner", length(x) - 1, allargs), "join")
  allargs$join <- NULL
  on <- extractArg("on", NA, length(x) - 1, allargs)
  allargs$on <- NULL
  using <- extractArg("using", NA, length(x) - 1, allargs)
  allargs$using <- NULL

  if (!all(xor(is.na(on), is.na(using))))
    stop("'on' and 'using' can't both be specified for the same join.")
  
  ## determine which database we'll use as the 'main' db.  All of the
  ## other databases will be attached as necessary.  By default, we'll
  ## use the database for the first element of 'x'.
  main <- extractArg("main", db(x[[1]]), NA, allargs)
  allargs$main <- NULL
  ## Get the other databases
  tableInfo <- data.frame(db = sapply(x, db),
                          sql = sapply(x, sql),
                          tableAlias = names(x), stringsAsFactors = FALSE)
  tableInfo <- within(tableInfo, ismain <- db == main)
  tableInfo$dbAlias <- ""
  i <- 0
  for (dbname in unique(tableInfo$db[!tableInfo$ismain])) {
    i <- i+1
    tableInfo$dbAlias[tableInfo$db == dbname] <- paste("dbAlias", i, sep = "")
  }

  ## set up the arguments for selectSQL
  allargs$tablesql <- tableSQL(paste(with(tableInfo,
                                          ifelse(ismain, sql, paste(dbAlias, sql, sep = "."))),
                                     tableInfo$tableAlias), join, on, using)
  allargs$cols <- cols

  ## Attach the other databases to the main db, run the query, and then detach
  dbc <- dbConnect(main)
  for (a in rows(unique(subset(tableInfo, !ismain, select = c(db, dbAlias))))) {
    r <- dbSendQuery(dbc, paste("attach database '", a$db, "' as ", a$dbAlias, sep = ""))
    dbClearResult(r)
  }
  d <- dbGetQuery(dbc, do.call(selectSQL, allargs))  
  for (a in rows(unique(subset(tableInfo, !ismain, select = c(db, dbAlias))))) {
    r <- dbSendQuery(dbc, paste("detach database", a$dbAlias))
    dbClearResult(r)
  }
  dbDisconnect(dbc)
  d
})
@

<<*>>=
setMethod("select", signature = c("dbframe", "list"), function(x, cols,...) {
  if (length(cols) == 1) return(select(x, cols[[1]],...))
  
  allargs <- list(...)
  comp <- extractArg("comp", "union all", length(cols) - 1, allargs)
  allargs$comp <- NULL
    
  if ("order.by" %in% names(allargs)) {
    ordertext <- paste(" order by ", paste(allargs[["order.by"]], collapse = ", "))
    allargs[["order.by"]] <- NULL
  } else {
    ordertext <- ""
  }

  ## if 'limit' has more than one entry, we'll apply it to each of
  ## the individual queries, otherwise we apply it at the end.
  eachlimit <- vector("list", length(cols))
  limtext <- ""
  if ("limit" %in% names(allargs)) {
    if (length(allargs[["limit"]]) > 1) {
      if (length(allargs[["limit"]]) != length(cols))
        stop("'limit' must have the same length as 'cols' or length 1")
      eachlimit <- as.list(allargs[["limit"]])
    } else {
      limtext <- paste(" limit ", allargs[["limit"]])
    }
    allargs[["limit"]] <- NULL
  }
  
  if (!all(sapply(cols, is.character)))
    stop("All elements of 'cols' must be characters")

  sqls <- sapply(seq_along(cols), function(j) {
    allargs$tablesql <- sql(x)
    allargs$cols <- cols[[j]]
    allargs$limit <- eachlimit[[j]]
    do.call(selectSQL, allargs)
  })
  dbc <- dbConnect(x)
  d <- dbGetQuery(dbc, paste(paste(sqls, c(comp, ""), collapse = " "), ordertext, limtext))
  dbDisconnect(dbc)
  d
})
@

<<*>>=
extractArg <- function(name, default, lengthReq, arglist) {
  v <- if (name %in% names(arglist)) arglist[[name]] else default
  if (is.na(lengthReq) | length(v) == lengthReq) return(v)
  else if (length(v) == 1) return(rep(v, lengthReq))
  else stop("Incorrect length of argument")
}
@

<<*>>=
tableSQL <- function(tablenames, join, on, using) {
  paste(tablenames[1], names(tablenames)[1],
        paste(join, tablenames[-1], names(tablenames)[-1], 
              c(ifelse(is.na(on), paste("using(", using, ")", sep = ""),
                       paste("on", on)))))
		     }
@
}
\keyword{methods}
\keyword{database}
