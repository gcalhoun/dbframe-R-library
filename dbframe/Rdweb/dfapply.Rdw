% -*- mode: noweb; noweb-default-code-mode: R-mode -*-
\name{dfapply}
\alias{dfapply}
\alias{pdfapply}
\title{A version of lapply that stacks data frames}
\description{A convenience function for when FUN returns a data.frame:
  this just stacks all of the data.frames.  And a "paired" version of
  dfapply; if FUN returns a list of data.frames, we want to stack all of
  the first elements into a single data.frame, all of the second
  elements, etc. 
}
\usage{
dfapply(x, FUN, row.names = FALSE, ...)

pdfapply(x, FUN, row.names = FALSE, ...)
}
\arguments{
  \item{x}{}
  \item{FUN}{}
  \item{row.names}{}
  \item{\dots}{}
}
\details{
%%  ~~ If necessary, more details than the description above ~~
}
\value{A data frame (for \code{dfapply}) or a list of data frames (for \code{pdfapply})}

\author{Gray Calhoun \email{gcalhoun@iastate.edu}}

\section{Implementation}{
<<*>>=
dfapply <- function(x, FUN, row.names = FALSE,...) 
  do.call(rbind, lapply(x, function(x,...) {
    d <- as.data.frame(FUN(x,...))
    if (!row.names) row.names(d) <- NULL
    d
  },...))
@

And the paired version:
<<*>>=
pdfapply <- function(x, FUN, row.names = FALSE, ...) {
  dlist <- lapply(x, FUN, ...)
  namesd <- names(dlist[[1]])
  dlist <- lapply(seq_along(dlist[[1]]), function(j) lapply(dlist, function(d) d[[j]]))
  dlist <- lapply(dlist, function(d) {
    dnew <- do.call(rbind, d)
    if (!row.names)
      row.names(dnew) <- NULL
    dnew
  })
  names(dlist) <- namesd
  dlist
}
@
}
  
\examples{
##---- Should be DIRECTLY executable !! ----
##-- ==>  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.
}
% Add one or more standard keywords, see file 'KEYWORDS' in the
% R documentation directory.
\keyword{utilities}
